/**
 * TypeScript wrapper for WASM vCAD engine
 */

import type { SceneDescription, SceneMetrics } from '@/types/scene'
import type { MeshData } from '@/types/mesh'

// Import WASM module (will be generated by wasm-pack)
let wasmModule: any = null

export class VcadEngine {
  private ready = false
  private engine: any = null

  async initialize() {
    if (this.ready) return

    try {
      // Dynamic import of WASM module
      wasmModule = await import('./pkg/vcad_engine.js')
      await wasmModule.default() // Initialize WASM

      this.engine = new wasmModule.VcadEngine()
      this.ready = true

      console.log(`vCAD WASM Engine v${this.engine.version} initialized`)
      console.log(`Manifold CSG: ${wasmModule.has_manifold() ? 'available' : 'not available'}`)
    } catch (error) {
      console.error('Failed to initialize WASM engine:', error)
      throw error
    }
  }

  private ensureReady() {
    if (!this.ready) {
      throw new Error('WASM engine not initialized. Call initialize() first.')
    }
  }

  // ========== Primitives ==========

  createCube(width: number, height: number, depth: number): string {
    this.ensureReady()
    return wasmModule.create_cube(width, height, depth)
  }

  createCylinder(radius: number, height: number): string {
    this.ensureReady()
    return wasmModule.create_cylinder(radius, height)
  }

  createSphere(radius: number): string {
    this.ensureReady()
    return wasmModule.create_sphere(radius)
  }

  createCone(radius: number, height: number): string {
    this.ensureReady()
    return wasmModule.create_cone(radius, height)
  }

  // ========== Sketch ==========

  createSketch(plane: 'XY' | 'XZ' | 'YZ'): string {
    this.ensureReady()
    return wasmModule.create_sketch(plane)
  }

  sketchAddLine(sketchId: string, x1: number, y1: number, x2: number, y2: number): string {
    this.ensureReady()
    return wasmModule.sketch_add_line(sketchId, x1, y1, x2, y2)
  }

  sketchAddCircle(sketchId: string, cx: number, cy: number, radius: number): string {
    this.ensureReady()
    return wasmModule.sketch_add_circle(sketchId, cx, cy, radius)
  }

  sketchAddRectangle(sketchId: string, x: number, y: number, width: number, height: number): string {
    this.ensureReady()
    return wasmModule.sketch_add_rectangle(sketchId, x, y, width, height)
  }

  // ========== Extrude ==========

  extrudeSketch(sketchId: string, height: number, heightBackward: number, draftAngle: number): string {
    this.ensureReady()
    return wasmModule.extrude_sketch(sketchId, height, heightBackward, draftAngle)
  }

  cutExtrude(bodyId: string, sketchId: string, height: number): string {
    this.ensureReady()
    return wasmModule.cut_extrude(bodyId, sketchId, height)
  }

  revolveSketch(
    sketchId: string,
    axisStartX: number,
    axisStartY: number,
    axisEndX: number,
    axisEndY: number,
    angle: number
  ): string {
    this.ensureReady()
    return wasmModule.revolve_sketch(sketchId, axisStartX, axisStartY, axisEndX, axisEndY, angle)
  }

  // ========== Fillet/Chamfer ==========

  applyFillet(bodyId: string, edgeIds: string[], radius: number): string {
    this.ensureReady()
    return wasmModule.apply_fillet(bodyId, edgeIds, radius)
  }

  applyChamfer(bodyId: string, edgeIds: string[], distance: number): string {
    this.ensureReady()
    return wasmModule.apply_chamfer(bodyId, edgeIds, distance)
  }

  // ========== Boolean Operations ==========

  booleanUnion(bodyId1: string, bodyId2: string): string {
    this.ensureReady()
    return wasmModule.boolean_union(bodyId1, bodyId2)
  }

  booleanDifference(bodyId1: string, bodyId2: string): string {
    this.ensureReady()
    return wasmModule.boolean_difference(bodyId1, bodyId2)
  }

  booleanIntersection(bodyId1: string, bodyId2: string): string {
    this.ensureReady()
    return wasmModule.boolean_intersection(bodyId1, bodyId2)
  }

  // ========== Sketch Operations (WASM) ==========

  trimElement(sketchJson: string, elementIndex: number, clickX: number, clickY: number): string {
    this.ensureReady()
    return wasmModule.sketch_trim_element(sketchJson, elementIndex, clickX, clickY)
  }

  filletLines(sketchJson: string, element1Index: number, element2Index: number, radius: number): string {
    this.ensureReady()
    return wasmModule.sketch_fillet_lines(sketchJson, element1Index, element2Index, radius)
  }

  offsetElement(sketchJson: string, elementIndex: number, distance: number, clickX: number, clickY: number): string {
    this.ensureReady()
    return wasmModule.sketch_offset_element(sketchJson, elementIndex, distance, clickX, clickY)
  }

  mirrorElement(sketchJson: string, elementIndex: number, axisStartX: number, axisStartY: number, axisEndX: number, axisEndY: number): string {
    this.ensureReady()
    return wasmModule.sketch_mirror_element(sketchJson, elementIndex, axisStartX, axisStartY, axisEndX, axisEndY)
  }

  linearPattern(sketchJson: string, elementIndex: number, count: number, dx: number, dy: number): string {
    this.ensureReady()
    return wasmModule.sketch_linear_pattern(sketchJson, elementIndex, count, dx, dy)
  }

  circularPattern(sketchJson: string, elementIndex: number, count: number, centerX: number, centerY: number, angle: number): string {
    this.ensureReady()
    return wasmModule.sketch_circular_pattern(sketchJson, elementIndex, count, centerX, centerY, angle)
  }

  // ========== UI Helper Functions ==========

  findElementAtPoint(sketchJson: string, pointX: number, pointY: number, threshold: number): number {
    this.ensureReady()
    return wasmModule.sketch_find_element_at_point(sketchJson, pointX, pointY, threshold)
  }

  calculateArcFrom3Points(p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): {
    center_x: number
    center_y: number
    radius: number
    start_angle: number
    end_angle: number
    valid: boolean
  } {
    this.ensureReady()
    return wasmModule.sketch_calculate_arc_from_3_points(p1x, p1y, p2x, p2y, p3x, p3y)
  }

  getSnapPoints(sketchJson: string, cursorX: number, cursorY: number, settingsJson: string): Array<{
    x: number
    y: number
    snap_type: string
    source_element: number | null
  }> {
    this.ensureReady()
    return wasmModule.sketch_get_snap_points(sketchJson, cursorX, cursorY, settingsJson)
  }

  solveConstraints(sketchJson: string): string {
    this.ensureReady()
    return wasmModule.sketch_solve_constraints(sketchJson)
  }

  // ========== Mesh Generation (WASM) ==========

  generateCubeMesh(width: number, height: number, depth: number): MeshData {
    this.ensureReady()
    return wasmModule.generate_cube_mesh(width, height, depth)
  }

  generateCylinderMesh(radius: number, height: number): MeshData {
    this.ensureReady()
    return wasmModule.generate_cylinder_mesh(radius, height)
  }

  generateSphereMesh(radius: number): MeshData {
    this.ensureReady()
    return wasmModule.generate_sphere_mesh(radius)
  }

  generateConeMesh(radius: number, height: number): MeshData {
    this.ensureReady()
    return wasmModule.generate_cone_mesh(radius, height)
  }

  // ========== Scene Building ==========

  async buildSceneGLB(scene: SceneDescription): Promise<Uint8Array | null> {
    this.ensureReady()

    try {
      const sceneJson = JSON.stringify(scene)
      const glbBytes = this.engine.build_scene_glb(sceneJson)
      return glbBytes
    } catch (error) {
      console.error('Failed to build scene GLB:', error)
      return null
    }
  }

  async inspectScene(scene: SceneDescription): Promise<SceneMetrics | null> {
    this.ensureReady()

    try {
      const sceneJson = JSON.stringify(scene)
      const metrics = this.engine.inspect_scene(sceneJson)
      return metrics
    } catch (error) {
      console.error('Failed to inspect scene:', error)
      return null
    }
  }
}

// Singleton instance
export const engine = new VcadEngine()
